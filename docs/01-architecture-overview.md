# Архитектура системы синтеза конфигураций динамических сетей

Версия документа: 1.0  
Последнее обновление: 9 февраля 2026 г.  

## Краткое описание системы

Система DynamicNetwork предназначена для автоматического синтеза конфигураций динамически изменяющихся сетей на основе:

- Временных графов топологии сети
- Потоков данных с требованиями к обработке
- Библиотеки доступных функций (процессы, транспорты, хранилища)

Ключевая задача: Основная цель приложения — понижение размерности сложной задачи маршрутизации в динамических сетях через автоматический синтез допустимых конфигураций, сведение временных графов, технологических ограничений и требований к передаче данных к компактному XML-описанию для оптимизационных алгоритмов.

## Архитектурные слои

Система состоит из четырёх слоёв:

1. Presentation (Представление)
   - WPF + MVVM
   - ViewModels: MainViewModel, StructConfigViewModel и др.
   - Views: MainWindow, вкладки интерфейса

2. Application (Приложение)
   - Сценарии использования: SynthesizeConfiguration, CheckReachability
   - Порты (интерфейсы): IFunctionLibraryProvider, IStructConfigRepository, IGraphSessionManager
   - DTO для передачи данных между слоями

3. Domain (Домен)
   - Агрегаты: FunctionLibrary, StructConfiguration
   - Сущности: DataFlow
   - Value Objects: TemporalGraph, Link, TimeInterval
   - Доменные сервисы: ISynthesisDomainService, IPathFindingDomainService

4. Infrastructure (Инфраструктура)
   - Репозитории: InMemoryStructConfigurationRepository, InMemoryDataFlowRepository
   - Фабрики: TemporalGraphFactory
   - Адаптеры: XmlFileStorageAdapter, JsonDataSourceAdapter

## Правила зависимостей между слоями

Важнейший принцип Чистой архитектуры: все зависимости направлены ВНУТРЬ к домену.

Domain:
- Не зависит ни от каких других слоёв
- Чистая бизнес-логика без привязки к фреймворкам

Application:
- Зависит только от Domain
- Не зависит от Infrastructure и Presentation

Infrastructure:
- Зависит от Application (реализует порты) и Domain
- Не зависит от Presentation

Presentation:
- Зависит только от Application
- Не зависит от Domain и Infrastructure напрямую

## Четыре ключевые доменные модели

Модель: FunctionLibrary
- Тип: Immutable Aggregate (неизменяемый агрегат)
- Паттерн взаимодействия: Провайдер (IFunctionLibraryProvider)
- Жизненный цикл: Singleton (один экземпляр на всё приложение)
- Ответственность: Глобальный справочник функций сети (процессы, транспорты, хранилища)

Модель: StructConfiguration
- Тип: Aggregate (агрегат)
- Паттерн взаимодействия: Репозиторий (IStructConfigurationRepository)
- Жизненный цикл: Множество экземпляров (по временным интервалам)
- Ответственность: Конфигурация сети на интервал постоянства структуры

Модель: DataFlow
- Тип: Entity (сущность)
- Паттерн взаимодействия: Репозиторий (IDataFlowRepository)
- Жизненный цикл: Множество экземпляров (по строковому идентификатору)
- Ответственность: Поток данных с объёмом и цепочкой трансформаций

Модель: TemporalGraph
- Тип: Value Object (объект-значение)
- Паттерн взаимодействия: Фабрика + Сессия (ITemporalGraphFactory + IGraphSessionManager)
- Жизненный цикл: Временный (существует только в рамках сессии)
- Ответственность: Снимок топологии сети на интервал времени

Почему разные паттерны?
- Библиотека функций — глобальное состояние системы → провайдер
- Конфигурации и потоки — коллекции сущностей → репозитории
- Графы — производные объекты, строящиеся "на лету" → фабрика + сессия

Обоснование:
- Такой подход преложен из соображений удобства использования в сценариях, когда 
предполагается, что система будет работать над одним логически связанным множеством узлов.
В таких сценариях входные данные временного графа будут различаться, но в силу их принадлежности одному множеству, допускается, что они работают с одной и той же библиотекой функций.
- В противном случае, пользователь не обременен проблемами изменения библиотеки функций:
система реализует удобные способы экспорта и ручного ввода необходимых параметров.

## Ключевые принципы проектирования

1. Иммутабельность агрегатов

Все изменения создают новый экземпляр вместо мутации существующего объекта.

Пример правильного подхода:
    var updated = library.AddProcesses(newProcesses);
    provider.Update(updated);

Пример неправильного подхода (запрещён):
    library.Processes.Add(newProcess); // Нарушает инварианты!

2. Чёткие границы слоёв через порты

Все зависимости инфраструктуры абстрагированы через интерфейсы в слое Application.

Пример порта:
    public interface IFileStoragePort
    {
        void SaveXml(XDocument document, string path);
    }

Пример адаптера (реализация порта):
    public class XmlFileStorageAdapter : IFileStoragePort 
    {
        public void SaveXml(XDocument document, string path) 
        {
            document.Save(path); // Деталь реализации
        }
    }

3. Координация через сценарии использования

Сценарии не содержат бизнес-логику — только координацию операций между портами и доменными сервисами.

Типичная структура сценария:
    1. Получение данных через порты (репозитории, провайдеры)
    2. Валидация входных параметров
    3. Вызов доменного сервиса для выполнения бизнес-логики
    4. Сохранение результатов через порты
    5. Возврат результата (обычно в виде DTO)

4. Защита инвариантов в агрегатах

Все бизнес-правила проверяются в конструкторах и методах агрегатов.

Пример инварианта в DataFlow:
    public DataFlow(string id, double volume, IEnumerable<FlowTransformation> transformations)
    {
        if (volume <= 0)
            throw new ArgumentException("Volume must be positive", nameof(volume));
        
        // Дополнительная валидация цепочки трансформаций...
    }

## Технологический стек

Язык: C# 12+
Архитектура: Чистая архитектура
DI: Microsoft.Extensions.DependencyInjection 9.0+
UI: WPF + MVVM (.NET 9+)
Визуализация: MSAGL (Microsoft Automatic Graph Layout)
Документация: XML-комментарии

## Сценарий синтеза конфигурации

Последовательность действий при синтезе:

1. Пользователь нажимает кнопку "Синтезировать" в интерфейсе
2. MainViewModel вызывает сценарий SynthesizeConfigurationUseCase.Execute()
3. Сценарий получает данные через порты:
   - Библиотеку функций через IFunctionLibraryProvider
   - Базовые конфигурации через IStructConfigurationRepository
   - Потоки данных через IDataFlowRepository
4. Сценарий собирает входные и выходные узлы из конфигураций
5. Сценарий вычисляет временной интервал синтеза:
   - Начало = минимальный Start из интервалов входных узлов
   - Конец = максимальный End из интервалов выходных узлов
6. Сценарий вызывает доменный сервис SynthesisDomainService.SynthesizeAll()
7. Доменный сервис выполняет:
   - Анализ достижимости (BFS по временным графам)
   - Планирование маршрутов для потоков
   - Агрегацию требований к ресурсам
   - Синтез конфигураций с подбором функций из библиотеки
8. Сценарий сохраняет результаты через репозиторий
9. Результат возвращается в ViewModel для отображения пользователю

## Дополнительная документация

02-domain-models.md — Детальное описание доменных моделей и их инвариантов
03-layers-and-boundaries.md — Границы слоёв и правила взаимодействия
04-use-cases.md — Все сценарии использования системы
05-data-flow-synthesis.md — Алгоритм синтеза конфигураций
adr/ — Архитектурные решения (почему выбраны те или иные паттерны)

## Советы для новых разработчиков

1. Начните изучение с папки Domain/ — это ядро системы
2. Следуйте правилу зависимостей: зависимости всегда направлены внутрь к домену
3. Не добавляйте бизнес-логику в Presentation — ViewModel только координирует операции
4. Используйте иммутабельность для агрегатов — все изменения создают новые экземпляры
5. Тестируйте доменные сервисы без моков — они не зависят от инфраструктуры

"Архитектура программного обеспечения — это искусство принимать решения, которые позволяют системе развиваться без постоянного рефакторинга"
— Роберт Мартин, "Чистая архитектура"