# Алгоритм синтеза конфигураций динамических сетей

Версия документа: 1.0  
Последнее обновление: 9 февраля 2026 г.  

## Введение

Алгоритм синтеза конфигураций является "сердцем" системы DynamicNetwork. Его задача — автоматически создать минимально необходимые конфигурации сети для обработки заданных потоков данных во всех временных интервалах, обеспечивая при этом достижимость данных от источников к стокам.

Ключевые принципы алгоритма:
- Минимизация ресурсов сети (процессы, транспорты, хранилища)
- Обеспечение достижимости всех потоков данных
- Учёт временной динамики топологии сети
- Использование только доступных функций из библиотеки

## Цель алгоритма синтеза

Основная цель: для каждого временного интервала постоянства структуры создать конфигурацию сети, которая:
1. Обеспечивает передачу и обработку всех заданных потоков данных
2. Использует минимально необходимый набор функций (процессов, транспортов, хранилищ)
3. Учитывает направления связей и доступные типы транспорта
4. Обеспечивает хранение промежуточных данных при необходимости

Дополнительные цели:
- Автоматическое определение необходимых функций на основе требований потоков
- Минимизация избыточных функций в конфигурациях
- Поддержка множественных потоков с разными требованиями
- Учёт временных ограничений (интервалы активности узлов и связей)

## Входные данные алгоритма

Алгоритм синтеза принимает следующие входные данные:

1. Временные графы (TemporalGraph[])
   - Последовательность снимков топологии сети на интервалы времени
   - Каждый граф содержит узлы, связи и временной интервал
   - Все узлы сети (включая изолированные) передаются в свойстве AllNetworkNodes

2. Потоки данных (DataFlow[])
   - Список потоков данных с объёмами и цепочками трансформаций
   - Каждый поток определяет последовательность преобразований от исходного к целевому типу
   - Объём данных влияет на требования к ёмкости хранилищ

3. Библиотека функций (FunctionLibrary)
   - Все доступные процессы (функции обработки данных)
   - Все доступные транспорты (функции передачи данных)
   - Все доступные хранилища (функции хранения данных)
   - Для каждой функции определены входные/выходные типы и параметры

4. Базовые конфигурации структуры (StructConfiguration[])
   - Конфигурации узлов и связей для каждого временного интервала
   - Содержат информацию о доступных процессах, транспортах и хранилищах на узлах/связях
   - Определяют входные и выходные узлы сети

5. Пути достижимости (ReachabilityPath[])
   - Все возможные пути от источников к стокам во временной сети
   - Получены через алгоритм BFS на временных графах
   - Содержат информацию о последовательности узлов, связей и временных интервалах

6. Запрос синтеза (StructConfigurationRequest)
   - Входные узлы (с указанием входных типов данных)
   - Выходные узлы (с указанием выходных типов данных)
   - Временной интервал синтеза (вычисляется автоматически)

## Этапы алгоритма синтеза

Алгоритм синтеза выполняется в пять последовательных этапов:

### Этап 1: Анализ достижимости

Цель: определить все возможные пути передачи данных от источников к стокам с учётом временной динамики сети.

Описание:
- Алгоритм выполняет поиск в ширину (BFS) по временным графам
- Учитывает смену временных интервалов (переходы между графами)
- Проверяет доступность связей на основе конфигураций (наличие активных транспортов)
- Учитывает направления связей (правые, левые, ненаправленные)
- Формирует полный список путей для каждого потока данных

Детали реализации:
- Начальное состояние: источник в первом доступном графе
- Генерация следующих состояний:
  * Переходы по рёбрам в текущем графе (если связь доступна)
  * Переходы к следующему графу без смены узла (временной переход)
- Проверка достижения цели: сравнение текущего узла с целевым
- Избегание циклов: отслеживание посещённых состояний (узел + граф + путь)
- Расчёт временного интервала пути: от минимального Start до максимального End

Результат этапа: список всех путей достижимости (ReachabilityPath[]) для всех потоков данных.

### Этап 2: Планирование маршрутов потоков

Цель: для каждого потока данных определить конкретные маршруты и необходимые трансформации на каждом узле и связи.

Описание:
- Для каждого потока данных фильтруются подходящие пути (от его источника к его стоку)
- Для каждого пути определяется последовательность трансформаций:
  * На узлах: какие процессы необходимы для преобразования типов данных
  * На связях: какие транспорты необходимы для передачи данных между узлами
- Учитываются объёмы данных для расчёта требований к хранилищам
- Формируются планы маршрутизации для каждого потока

Детали реализации:
- Определение начального типа данных из идентификатора потока
- Проход по каждому ребру пути:
  * Проверка необходимости трансформации перед передачей по связи
  * Определение требуемого процесса для преобразования типа
  * Определение требуемого транспорта для передачи данных
  * Учёт объёма данных для расчёта ёмкости хранилищ
- Обработка финального узла: проверка соответствия выходного типа
- Формирование плана маршрутизации (FlowRoutePlan) для каждого потока

Результат этапа: список планов маршрутизации (FlowRoutePlan[]) для всех потоков данных.

### Этап 3: Агрегация требований к ресурсам

Цель: собрать все требования к ресурсам сети по узлам, связям и временным интервалам.

Описание:
- Агрегация требований к процессам по узлам и интервалам
- Агрегация требований к транспортам по связям и интервалам
- Агрегация требований к хранилищам по узлам, типам данных и объёмам
- Учёт множественных потоков, проходящих через один узел/связь
- Расчёт минимально необходимых ресурсов для удовлетворения всех требований

Детали реализации:
- Для каждого узла в каждом интервале:
  * Сбор всех требуемых трансформаций (входной тип → выходной тип)
  * Формирование множества необходимых процессов
- Для каждой связи в каждом интервале:
  * Сбор всех требуемых типов данных для передачи
  * Формирование множества необходимых транспортов
- Для каждого узла по типам данных:
  * Суммирование объёмов данных для каждого типа
  * Расчёт минимальной необходимой ёмкости хранилищ
- Формирование структуры требований (ResourceRequirements)

Результат этапа: агрегированные требования к ресурсам (ResourceRequirements) по всем узлам, связям и интервалам.

### Этап 4: Синтез конфигураций узлов и связей

Цель: на основе агрегированных требований сформировать конкретные конфигурации узлов и связей для каждого временного интервала.

Описание:
- Для каждого временного интервала создаётся новая конфигурация структуры
- Для каждого узла в интервале:
  * Подбор подходящих процессов из библиотеки функций
  * Активация необходимых процессов (формирование ActiveProcesses)
  * Распределение ёмкостей хранилищ по типам данных
  * Формирование конфигурации узла (NodeConfiguration)
- Для каждой связи в интервале:
  * Подбор подходящих транспортов из библиотеки функций
  * Активация необходимых транспортов (формирование ActiveTransports)
  * Формирование конфигурации связи (LinkConfiguration)
- Создание иммутабельных конфигураций для каждого интервала

Детали реализации:
- Синтез конфигурации узла:
  * Перебор всех требуемых трансформаций для узла
  * Поиск в библиотеке процесса с подходящими входным/выходным типами
  * Добавление найденного процесса в ActiveProcesses
  * Расчёт ёмкостей хранилищ на основе суммарных объёмов данных
  * Создание нового иммутабельного объекта NodeConfiguration
- Синтез конфигурации связи:
  * Перебор всех требуемых типов данных для связи
  * Поиск в библиотеке транспорта с подходящим типом данных
  * Добавление найденного транспорта в ActiveTransports
  * Создание нового иммутабельного объекта LinkConfiguration
- Формирование конфигурации структуры для интервала

Результат этапа: список синтезированных конфигураций (StructConfiguration[]) для всех временных интервалов.

### Этап 5: Формирование итоговых конфигураций

Цель: завершить синтез, сохранить результаты и подготовить данные для экспорта.

Описание:
- Сортировка конфигураций по времени (от ранних к поздним интервалам)
- Очистка репозитория от старых конфигураций
- Сохранение синтезированных конфигураций в репозиторий
- Подготовка результатов для отображения пользователю
- Формирование сообщения о результатах синтеза

Детали реализации:
- Сортировка конфигураций: по возрастанию Interval.Start
- Удаление старых конфигураций: полная очистка репозитория перед сохранением новых
- Сохранение новых конфигураций: добавление каждой конфигурации в репозиторий
- Формирование результата: список синтезированных конфигураций + статистика
- Подготовка сообщения: количество конфигураций, интервал синтеза, статус

Результат этапа: сохранённые конфигурации в репозитории и результат операции синтеза.

## Выходные данные алгоритма

Результатом работы алгоритма синтеза являются:

1. Синтезированные конфигурации структуры (StructConfiguration[])
   - Конфигурация для каждого временного интервала
   - Содержат активные процессы на узлах (ActiveProcesses)
   - Содержат активные транспорты на связях (ActiveTransports)
   - Содержат распределённые ёмкости хранилищ (StorageCapacities)

2. Статистика синтеза
   - Количество созданных конфигураций
   - Временной интервал синтеза (начало и конец)
   - Количество обработанных потоков данных
   - Количество найденных путей достижимости

3. Сообщение о результате
   - Успешное завершение с указанием количества конфигураций
   - Ошибки при отсутствии входных/выходных узлов
   - Ошибки при отсутствии достижимых путей
   - Ошибки при недостатке функций в библиотеке

## Пример работы алгоритма

Рассмотрим упрощённый пример синтеза для одного потока данных:

Исходные данные:
- Поток данных: "video_stream" с объёмом 100 ГБ
  * Трансформации: video_4k → video_1080p → video_h264
- Временные графы: 3 интервала (0-100, 100-200, 200-300)
- Узлы: A (источник), B (промежуточный), C (сток)
- Связи: A-B (интервалы 0-200), B-C (интервалы 100-300)
- Библиотека функций:
  * Процессы: "decode_4k" (video_4k → video_1080p), "encode_h264" (video_1080p → video_h264)
  * Транспорты: "fiber" (тип video, ёмкость 200 ГБ)
  * Хранилища: "buffer" (типы video)

Этап 1: Анализ достижимости
- Найден путь: A (интервал 0-100) → B (интервал 100-200) → C (интервал 200-300)
- Временной интервал пути: 0-300

Этап 2: Планирование маршрутов
- На узле A: требуется процесс "decode_4k" для преобразования video_4k → video_1080p
- На связи A-B: требуется транспорт "fiber" для передачи video_1080p
- На узле B: требуется процесс "encode_h264" для преобразования video_1080p → video_h264
- На связи B-C: требуется транспорт "fiber" для передачи video_h264
- На узле B: требуется хранилище "buffer" для хранения 100 ГБ video_1080p

Этап 3: Агрегация требований
- Узел A (интервал 0-100): требуется процесс "decode_4k"
- Связь A-B (интервал 0-200): требуется транспорт "fiber"
- Узел B (интервал 100-200): требуется процесс "encode_h264", хранилище "buffer" (100 ГБ)
- Связь B-C (интервал 100-300): требуется транспорт "fiber"
- Узел C (интервал 200-300): не требуется активных функций (сток)

Этап 4: Синтез конфигураций
- Конфигурация для интервала 0-100:
  * Узел A: ActiveProcesses = ["decode_4k"]
  * Узел B: StorageCapacities = {"buffer": 100.0}
  * Связь A-B: ActiveTransports = ["fiber"]
- Конфигурация для интервала 100-200:
  * Узел B: ActiveProcesses = ["encode_h264"], StorageCapacities = {"buffer": 100.0}
  * Связь A-B: ActiveTransports = ["fiber"]
  * Связь B-C: ActiveTransports = ["fiber"]
- Конфигурация для интервала 200-300:
  * Связь B-C: ActiveTransports = ["fiber"]

Этап 5: Формирование итоговых конфигураций
- Сохранены 3 конфигурации для интервалов 0-100, 100-200, 200-300
- Сообщение: "Синтез завершён: создано 3 конфигурации для интервала [0, 300]"

Результат: сеть настроена для обработки потока video_stream с минимально необходимыми ресурсами.

## Особенности и ограничения алгоритма

### Особенности реализации

1. Иммутабельность конфигураций
   - Все конфигурации создаются как новые иммутабельные объекты
   - Изменения существующих конфигураций невозможны — только замена
   - Гарантия целостности данных и потокобезопасность

2. Минимизация ресурсов
   - Алгоритм подбирает только необходимые функции для каждого узла/связи
   - Неактивные функции (из Enabled*) не включаются в конфигурацию
   - Оптимизация ёмкостей хранилищ на основе суммарных объёмов данных

3. Учёт временной динамики
   - Конфигурации создаются отдельно для каждого временного интервала
   - Учитываются изменения топологии сети во времени
   - Поддержка временных переходов между графами

4. Множественные потоки
   - Алгоритм обрабатывает все потоки данных одновременно
   - Агрегирует требования от всех потоков для каждого узла/связи
   - Обеспечивает совместную работу потоков в сети

### Ограничения алгоритма

1. Жадный подход к подбору функций
   - Алгоритм подбирает первый подходящий процесс/транспорт из библиотеки
   - Не выполняет оптимизацию по производительности или стоимости
   - Для оптимального подбора требуется расширение алгоритма

2. Отсутствие балансировки нагрузки (задача следующего модуля)
   - При множественных путях выбираются все доступные пути
   - Нет распределения потоков по путям для балансировки нагрузки
   - Все потоки используют все доступные пути одновременно

3. Упрощённая модель хранилищ
   - Ёмкость хранилищ рассчитывается как сумма объёмов всех потоков
   - Не учитывается временная локализация данных (данные могут освобождать место)
   - Для точного расчёта требуется более сложная модель
   - При необходимости, в дальнейшем, предполагается, что объемы можно будет "зашить" вручную

4. Отсутствие учёта приоритетов потоков
   - Все потоки данных обрабатываются с одинаковым приоритетом
   - Нет механизма выделения ресурсов для критически важных потоков
   - Для приоритезации требуется расширение алгоритма

### Возможные улучшения

1. Оптимизация подбора функций
   - Введение критериев выбора (производительность, стоимость, энергопотребление)
   - Алгоритмы поиска оптимального набора функций
   - Поддержка нескольких вариантов конфигурации с выбором лучшего

2. Балансировка нагрузки
   - Распределение потоков по доступным путям
   - Учёт загрузки узлов и связей при маршрутизации
   - Динамическая перенастройка конфигураций при изменении нагрузки

3. Уточнённая модель хранилищ
   - Учёт временной локализации данных
   - Расчёт минимально необходимой ёмкости с учётом времени хранения
   - Поддержка иерархических хранилищ (кэш, основное, архив)

4. Поддержка приоритетов
   - Введение приоритетов для потоков данных
   - Выделение гарантированных ресурсов для критических потоков
   - Механизмы отказоустойчивости для важных потоков

## Связанные документы

01-architecture-overview.md — Обзор архитектуры системы
02-domain-models.md — Детальное описание доменных моделей
03-layers-and-boundaries.md — Границы слоёв и правила взаимодействия
04-use-cases.md — Сценарии использования системы
06-reachability-service.md - Сервис достижимости